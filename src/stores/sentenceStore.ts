import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface FocusedWord {
  id: string;
  wordText: string;
  startPosition: number;
  endPosition: number;
  pronunciation?: string;
}

export interface SentenceTranslation {
  id: string;
  targetLanguage: string;
  translatedText: string;
  translationType: 'native' | 'target' | 'learning';
  isAutoGenerated: boolean;
}

export interface WordPhrase {
  id: string;
  phraseText: string;
  targetLanguage: string;
}

export interface LearningRecord {
  id: string;
  sentenceId: string;
  learningType: 'sentence_translation' | 'word_learning' | 'pronunciation';
  familiarityLevel: 'unfamiliar' | 'familiar' | 'mastered';
  reviewCount: number;
  lastReviewedAt?: Date;
  nextReviewAt?: Date;
  easeFactor: number;
  intervalDays: number;
}

export interface Sentence {
  id: string;
  originalText: string;
  languageCode: string;
  sourceType: 'book' | 'manual' | 'clipboard' | 'import';
  sourceReference?: string;
  translations: SentenceTranslation[];
  focusedWords: FocusedWord[];
  wordPhrases: WordPhrase[];
  learningRecord?: LearningRecord;
  createdAt: Date;
  updatedAt: Date;
}

interface SentenceState {
  sentences: Sentence[];
  currentSentence: Sentence | null;
  isLoading: boolean;
  
  // Actions
  addSentence: (sentence: Omit<Sentence, 'id' | 'createdAt' | 'updatedAt'>) => void;
  updateSentence: (id: string, updates: Partial<Sentence>) => void;
  deleteSentence: (id: string) => void;
  getSentence: (id: string) => Sentence | undefined;
  getSentencesByLanguage: (languageCode: string) => Sentence[];
  getSentencesForReview: () => Sentence[];
  updateLearningRecord: (sentenceId: string, familiarityLevel: 'unfamiliar' | 'familiar' | 'mastered') => void;
  searchSentences: (query: string) => Sentence[];
  setCurrentSentence: (sentence: Sentence | null) => void;
}

export const useSentenceStore = create<SentenceState>()(
  persist(
    (set, get) => ({
      sentences: [],
      currentSentence: null,
      isLoading: false,

      addSentence: (sentenceData) => {
        const newSentence: Sentence = {
          ...sentenceData,
          id: Date.now().toString(),
          createdAt: new Date(),
          updatedAt: new Date()
        };

        set((state) => ({
          sentences: [...state.sentences, newSentence]
        }));
      },

      updateSentence: (id, updates) => {
        set((state) => ({
          sentences: state.sentences.map(sentence =>
            sentence.id === id
              ? { ...sentence, ...updates, updatedAt: new Date() }
              : sentence
          )
        }));
      },

      deleteSentence: (id) => {
        set((state) => ({
          sentences: state.sentences.filter(sentence => sentence.id !== id)
        }));
      },

      getSentence: (id) => {
        return get().sentences.find(sentence => sentence.id === id);
      },

      getSentencesByLanguage: (languageCode) => {
        return get().sentences.filter(sentence => sentence.languageCode === languageCode);
      },

      getSentencesForReview: () => {
        const now = new Date();
        return get().sentences.filter(sentence => {
          if (!sentence.learningRecord) return true;
          return !sentence.learningRecord.nextReviewAt || sentence.learningRecord.nextReviewAt <= now;
        });
      },

      updateLearningRecord: (sentenceId, familiarityLevel) => {
        set((state) => ({
          sentences: state.sentences.map(sentence => {
            if (sentence.id !== sentenceId) return sentence;

            const currentRecord = sentence.learningRecord;
            const newRecord: LearningRecord = {
              id: currentRecord?.id || Date.now().toString(),
              sentenceId,
              learningType: 'sentence_translation',
              familiarityLevel,
              reviewCount: (currentRecord?.reviewCount || 0) + 1,
              lastReviewedAt: new Date(),
              easeFactor: currentRecord?.easeFactor || 2.5,
              intervalDays: currentRecord?.intervalDays || 1
            };

            // 基于Anki算法计算下次复习时间
            const nextReviewDate = new Date();
            if (familiarityLevel === 'mastered') {
              newRecord.intervalDays = Math.floor(newRecord.intervalDays * newRecord.easeFactor);
              nextReviewDate.setDate(nextReviewDate.getDate() + newRecord.intervalDays);
            } else if (familiarityLevel === 'familiar') {
              newRecord.intervalDays = Math.max(1, Math.floor(newRecord.intervalDays * 1.3));
              nextReviewDate.setDate(nextReviewDate.getDate() + newRecord.intervalDays);
            } else {
              newRecord.intervalDays = 1;
              nextReviewDate.setDate(nextReviewDate.getDate() + 1);
            }

            newRecord.nextReviewAt = nextReviewDate;

            return {
              ...sentence,
              learningRecord: newRecord
            };
          })
        }));
      },

      searchSentences: (query) => {
        const lowercaseQuery = query.toLowerCase();
        return get().sentences.filter(sentence =>
          sentence.originalText.toLowerCase().includes(lowercaseQuery) ||
          sentence.translations.some(translation =>
            translation.translatedText.toLowerCase().includes(lowercaseQuery)
          ) ||
          sentence.focusedWords.some(word =>
            word.wordText.toLowerCase().includes(lowercaseQuery)
          )
        );
      },

      setCurrentSentence: (sentence) => {
        set({ currentSentence: sentence });
      }
    }),
    {
      name: 'sentence-storage'
    }
  )
);
