250905 V1需求

请帮我生成一个基于react npx create-app@5 的网站。先说程序的基本需求。


1 网站页面架构。（需要较好的可扩展性，未来需要其他功能）

登陆页面
    语言学习：
        我说应用场景，请你帮我扩写这个东西的ui结构，然后再慢慢调整。。具体场景是，我通过读书或其他方式导入，会导入很多不同语言的句子。我的母语是中文，需要精通的语言是英语。需要学习的语言有日语、法语和闽南语。（未来用户可以定义一个母语、一个需要精通的语言，和<=3个正在学习的语言）。
        有下面几种情况：
            （1）我以某种方式（包括从书籍中）导入一个句子。导入一个句子中的一个或几个单词。然后每一条导入都会变成一条句子的数据记录。这个记录应当包括：（1）原句本身（2）原句本身的语言标签（3）原句中聚焦的一个或几个单词（可选，有的时候句子中不包括这个人）。（4）原句在母语和待精通语言中的翻译（如果原句就是母语或待精通语言，则这个直接复制原句就行）。（5）如果有聚焦的一个或几个单词，则造出一个原句+一个待精通精通语言的短句。（6）特殊情况：有一个“发音”栏。如果出现的任何语言中有日语，则需要把单词块的汉字后面加上（平假名），例如変態（へんたい）にする，也需要在日语的句子中以同样的方式填写。比如，今日（きょお）は、俺（おれ）が変態（へんたい）にする。（7）录入日期、和又anki学习调整的时序熟悉度。这个我不知道怎么做。但是要有科学的记忆曲线。
            （2）我每天打开这个语言学习工具，则用anki的方法进行翻卡片式学习。主要学习方式，就是把母语句子转化成待精通语言的句子，或把母语句子/待精通语言句子翻译成其他语言的句子。每一句话我可以至少选择 熟悉、不熟悉、完全掌握着三种选项。

        --------------------------------------------------------
        ## 语言学习模块UI结构需求文档

        ### 1. 语言设置页面
        - 功能：允许用户设置母语、需要精通的语言、以及最多3个正在学习的语言。
        - 主要UI元素：
            - 语言选择下拉框（母语、精通语言、学习语言1-3）
            - 保存/应用按钮

        ### 2. 句子导入页面
        - 功能：导入多语言句子，支持从书籍、剪贴板、手动输入等方式。
        - 主要UI元素：
            - 句子输入框（支持多行）
            - 语言标签选择器
            - 聚焦单词选择器（可选，支持高亮/多选）
            - 翻译输入/自动翻译区（母语、精通语言）
            - 发音输入区（如为日语，支持汉字+平假名自动/手动填写）
            - 录入日期显示/选择器
            - 提交/保存按钮
            - 句子记录列表（展示已导入的句子，支持编辑/删除）

        ### 3. 句子详情与编辑页面
        - 功能：查看和编辑单条句子详细信息。
        - 主要UI元素：
            - 原句及语言标签
            - 聚焦单词高亮显示
            - 各语言翻译展示与编辑
            - 发音信息（如有）
            - 录入日期、记忆曲线熟悉度显示
            - 编辑/保存/删除按钮

        ### 4. 学习（复习）页面
        - 功能：基于Anki记忆曲线的卡片式学习。
        - 主要UI元素：
            - 卡片展示区（正面：母语/精通语言/学习语言的句子，背面：目标语言翻译/聚焦单词短句/发音等）
            - 熟悉度选择按钮（熟悉、不熟悉、完全掌握）
            - 下一个/上一个卡片按钮
            - 进度条/今日学习统计
            - 复习计划/记忆曲线可视化（可选）

        ### 5. 句子管理与搜索页面
        - 功能：管理所有已导入的句子，支持搜索、筛选、批量操作。
        - 主要UI元素：
            - 搜索框（支持按语言、单词、日期等筛选）
            - 句子列表（可分页/无限滚动）
            - 批量选择、删除、导出按钮

        ### 6. 其他功能建议
        - 多端同步（可选，后续扩展）
        - 用户自定义标签/分组
        - 统计与学习报告

        ### 7. 技术建议
        - 前端建议使用React+Ant Design或MUI等UI库，便于表单、表格、卡片等组件快速搭建。
        - 句子、单词、翻译等数据结构建议统一建模，便于后续扩展和维护。
        - 记忆曲线可参考Anki算法，后端可用Python/Node等实现。



    书架
        上栏 - 搜索框
        中栏 - 近期阅读书籍
        中栏目2 - 按照某种顺序（如书名、长度、上次阅读时间）排序的书籍，或搜索框中搜索到的书籍
        下栏 - 回到上一界面。

        阅读器页面（直接点击书籍后进入）
            上栏：全文搜索、查看划线/查询/翻译/学习历史
            中栏：可翻页阅读器（要考虑到手机端翻页和网页端翻页的不同）。可以支持长按划线后，右键弹出类似“微信读书”划线后的几个栏目，包括复制、划线、查询、翻译、学习这几个功能（后续在usercase中定义）。
            下栏：（1）目录、（2）笔记/热门划线、（3）阅读进度/阅读时长/画线条、（4）翻译按钮（可toggle）（5）返回书架(保存当前阅读进度)
        总结器页面
            左栏：总结器
                左栏上栏：返回书架
                左栏中栏：
                    （1）书名
                    （2）可以collapse的总结内容。具体来说，就是每一个目录标题 + 这一章内容的三句话之内的总结为第一级。
                        （有些书籍的目录可能是多级的，我们这里要的是最底层、无法继续collapse的目录条目。只要原书的目录级数多1级，则collapse的菜单也跟着同步多一级）
                    有个collaspe按钮。点击这个按钮之后，会显示出5-20个这一章的总结句
                        （他们都由ai自动生成，生成的时候提前埋好总结句标签和文章句子的位置对应）。
                    点击总结句子，则右栏会自动显示这个总结句对应的文章片段。
                    和这些总结句组平行的第二级内容中，加入另一个块，叫做“建议”。这个也是AI生成的内容
                        （如果在总结书籍的时候允许，则每个章节也根据情况生成几个“建议”的内容，每个建议也要和5-20个总结句一样，和书籍的句子产生关联。只要点击之后，右栏会自动跳到建议所对应的内容）
            右栏：点击总结器的某句话，右边则显示阅读器，并跳到这句话对应的位置。右栏就是给阅读器做准备的。


可参考小工具：
    ########################################################
    def unified_send_request(endpoint: str, model: str, user_message: str, max_retries=3, delay=2) -> str:
        endpoints_info = {
            "laozhang": {
                "url": "https://api.laozhang.ai/v1/chat/completions",
                "api_key": "sk-zHKiyuo8GkU5BKyf50963cDf19Dd41B89aE6F31cAe73235a"
            },
            "poe": {
                "url": "https://api.poe.com/v1/chat/completions",
                "api_key": "vckcyvATpucnNfNne4ESXS1bsAcn7Myff2E5xyce3v0"
            },
            "yyds": {
                "url": "https://ai-yyds.com/v1/chat/completions",
                "api_key": "sk-KZw5hQpbZNAnRtAOB3Ba667264C64d1c9bBf7e2314E56fEd"
            },
            "pro": {
                "url": "https://pro.aiskt.com/v1/chat/completions",
                "api_key": "sk-c2FPm9GKWVXVeJg7CdF64cF943784aA0858e2a7303380f20"
            },
            "aihk": {
                "url": "https://api.openai-hk.com/v1/chat/completions",
                "api_key": "hk-y7nrnu1000047794311a7c3256c7755ced39bbd488913924"
            },
            "duck": {
                "url": "https://api.duckagi.com/v1/chat/completions",
                "api_key": "sk-FdRrPSdKf3XxZtrRhQPHbR66nUsKmapmWK5lfofsOxmMxz3a"
            },
            "us": {
                "url": "https://www.gptapi.us/v1/chat/completions",
                "api_key": "sk-jutGGILLVaOhy9fX14F90e19A42a49C1B12f115eEa6cD29a"
            },
            "apiyi": {
                "url": "https://www.apiyi.com/v1/chat/completions",
                "api_key": "sk-nftGOS33m4ZNhPfu575984D2Ed6e4aB9B2627b1c799FcA3"
            },
            "router": {
                "url": "https://openrouter.ai/api/v1/chat/completions",
                "api_key": "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"
            }
        }
        # 定义轮动优先级：先用用户选择的endpoint，再依次尝试其他预设顺序
        fallback_order = ["poe","laozhang", "router", "aihk", "poe"]
        endpoints_to_try = []
        if endpoint in endpoints_info:
            endpoints_to_try.append(endpoint)
        for ep in fallback_order:
            if ep not in endpoints_to_try and ep in endpoints_info:
                endpoints_to_try.append(ep)

        import random, time, json, requests, logging
        last_error = ""
        for ep in endpoints_to_try:
            url = endpoints_info[ep]["url"]
            api_key_local = endpoints_info[ep]["api_key"]
            headers = {
                "Authorization": f"Bearer {api_key_local}",
                "Content-Type": "application/json"
            }
            max_tokens = 5000 if model == "gpt-4o" else 20000
            payload = {
                "model": model,
                "messages": [
                    {"role": "user", "content": user_message}
                ],
                "max_completion_tokens": max_tokens
            }
            for attempt in range(max_retries):
                # 加入随机延时，避免请求过快被服务器拒绝
                time.sleep(random.uniform(0.2, 1.0))
                try:
                    start_time = time.time()
                    response = requests.post(url, headers=headers, data=json.dumps(payload))
                    if response.status_code == 200:
                        end_time = time.time()
                        print(f"[unified_send_request] Endpoint {ep} succeeded in {end_time - start_time:.2f}s")
                        try:
                            return response.json()["choices"][0]["message"]["content"]
                        except (KeyError, IndexError) as e:
                            last_error = f"Error parsing response from endpoint {ep}: {e}"
                    else:
                        last_error = f"Error: Endpoint {ep} status code={response.status_code}, detail={response.text}"
                except Exception as e:
                    last_error = f"Exception from endpoint {ep}: {str(e)}"
                # 指数退避延时
                time.sleep(delay * (2 ** attempt))
            print(f"Endpoint {ep} failed after {max_retries} attempts. Trying next endpoint...")
        return f"Exception: All endpoints failed. Last error: {last_error}"




当下任务：
请生成可以直接转化成uml的、直观的数据模型和各个表之间的关系。

## 数据模型设计

### 核心实体表

#### 1. 用户表 (Users)
```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    native_language VARCHAR(10) NOT NULL,  -- 母语代码 (如 'zh-CN')
    target_language VARCHAR(10) NOT NULL,  -- 精通语言代码 (如 'en-US')
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

#### 2. 用户学习语言表 (User_Learning_Languages)
```sql
CREATE TABLE user_learning_languages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    language_code VARCHAR(10) NOT NULL,  -- 学习语言代码
    language_name VARCHAR(50) NOT NULL,  -- 语言名称
    learning_order TINYINT NOT NULL,     -- 学习优先级 (1-3)
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE KEY unique_user_language (user_id, language_code)
);
```

#### 3. 句子表 (Sentences)
```sql
CREATE TABLE sentences (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    original_text TEXT NOT NULL,         -- 原句内容
    language_code VARCHAR(10) NOT NULL,  -- 原句语言
    source_type ENUM('book', 'manual', 'clipboard', 'import') DEFAULT 'manual',
    source_reference VARCHAR(255),       -- 来源引用 (如书名、页码)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_language (user_id, language_code),
    INDEX idx_created_at (created_at)
);
```

#### 4. 句子翻译表 (Sentence_Translations)
```sql
CREATE TABLE sentence_translations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    sentence_id BIGINT NOT NULL,
    target_language VARCHAR(10) NOT NULL,  -- 目标语言
    translated_text TEXT NOT NULL,         -- 翻译内容
    translation_type ENUM('native', 'target', 'learning') NOT NULL,  -- 翻译类型
    is_auto_generated BOOLEAN DEFAULT FALSE,  -- 是否自动生成
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (sentence_id) REFERENCES sentences(id) ON DELETE CASCADE,
    UNIQUE KEY unique_sentence_target (sentence_id, target_language, translation_type)
);
```

#### 5. 聚焦单词表 (Focused_Words)
```sql
CREATE TABLE focused_words (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    sentence_id BIGINT NOT NULL,
    word_text VARCHAR(255) NOT NULL,     -- 单词文本
    word_position_start INT NOT NULL,    -- 单词在原句中的起始位置
    word_position_end INT NOT NULL,      -- 单词在原句中的结束位置
    pronunciation VARCHAR(500),          -- 发音信息 (如日语的平假名)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (sentence_id) REFERENCES sentences(id) ON DELETE CASCADE,
    INDEX idx_sentence_id (sentence_id)
);
```

#### 6. 单词短句表 (Word_Phrases)
```sql
CREATE TABLE word_phrases (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    focused_word_id BIGINT NOT NULL,
    phrase_text TEXT NOT NULL,           -- 包含该单词的短句
    target_language VARCHAR(10) NOT NULL, -- 短句语言
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (focused_word_id) REFERENCES focused_words(id) ON DELETE CASCADE
);
```

#### 7. 学习记录表 (Learning_Records)
```sql
CREATE TABLE learning_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    sentence_id BIGINT NOT NULL,
    learning_type ENUM('sentence_translation', 'word_learning', 'pronunciation') NOT NULL,
    familiarity_level ENUM('unfamiliar', 'familiar', 'mastered') NOT NULL,
    review_count INT DEFAULT 0,          -- 复习次数
    last_reviewed_at TIMESTAMP NULL,     -- 最后复习时间
    next_review_at TIMESTAMP NULL,       -- 下次复习时间 (基于记忆曲线)
    ease_factor DECIMAL(3,2) DEFAULT 2.50,  -- 难度因子 (Anki算法)
    interval_days INT DEFAULT 1,         -- 复习间隔天数
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (sentence_id) REFERENCES sentences(id) ON DELETE CASCADE,
    UNIQUE KEY unique_user_sentence_type (user_id, sentence_id, learning_type),
    INDEX idx_next_review (next_review_at),
    INDEX idx_user_review (user_id, next_review_at)
);
```

#### 8. 书籍表 (Books)
```sql
CREATE TABLE books (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    title VARCHAR(255) NOT NULL,
    author VARCHAR(255),
    language_code VARCHAR(10) NOT NULL,
    file_path VARCHAR(500),              -- 文件路径
    file_type ENUM('pdf', 'epub', 'txt', 'mobi') NOT NULL,
    total_pages INT,
    current_page INT DEFAULT 0,          -- 当前阅读页码
    reading_progress DECIMAL(5,2) DEFAULT 0.00,  -- 阅读进度百分比
    total_reading_time INT DEFAULT 0,    -- 总阅读时间(分钟)
    last_read_at TIMESTAMP NULL,         -- 最后阅读时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_language (user_id, language_code),
    INDEX idx_last_read (last_read_at)
);
```

#### 9. 书籍章节表 (Book_Chapters)
```sql
CREATE TABLE book_chapters (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    book_id BIGINT NOT NULL,
    chapter_title VARCHAR(255) NOT NULL,
    chapter_order INT NOT NULL,          -- 章节顺序
    start_page INT,                      -- 起始页码
    end_page INT,                        -- 结束页码
    parent_chapter_id BIGINT NULL,       -- 父章节ID (支持多级目录)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_chapter_id) REFERENCES book_chapters(id) ON DELETE CASCADE,
    INDEX idx_book_order (book_id, chapter_order)
);
```

#### 10. 书籍总结表 (Book_Summaries)
```sql
CREATE TABLE book_summaries (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    book_id BIGINT NOT NULL,
    chapter_id BIGINT NULL,              -- 章节总结 (NULL表示整本书总结)
    summary_type ENUM('chapter', 'book', 'suggestion') NOT NULL,
    summary_text TEXT NOT NULL,          -- 总结内容
    summary_order INT NOT NULL,          -- 总结顺序
    start_position INT,                  -- 对应原文起始位置
    end_position INT,                    -- 对应原文结束位置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,
    FOREIGN KEY (chapter_id) REFERENCES book_chapters(id) ON DELETE CASCADE,
    INDEX idx_book_chapter (book_id, chapter_id),
    INDEX idx_summary_type (summary_type)
);
```

#### 11. 阅读笔记表 (Reading_Notes)
```sql
CREATE TABLE reading_notes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    book_id BIGINT NOT NULL,
    sentence_id BIGINT NULL,             -- 关联的句子 (可选)
    note_type ENUM('highlight', 'translation', 'query', 'learning') NOT NULL,
    note_text TEXT,                      -- 笔记内容
    start_position INT,                  -- 在原文中的起始位置
    end_position INT,                    -- 在原文中的结束位置
    page_number INT,                     -- 页码
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,
    FOREIGN KEY (sentence_id) REFERENCES sentences(id) ON DELETE SET NULL,
    INDEX idx_user_book (user_id, book_id),
    INDEX idx_note_type (note_type)
);
```

### 表关系图 (ERD)

```
Users (1) ──→ (N) User_Learning_Languages
Users (1) ──→ (N) Sentences
Users (1) ──→ (N) Books
Users (1) ──→ (N) Learning_Records
Users (1) ──→ (N) Reading_Notes

Sentences (1) ──→ (N) Sentence_Translations
Sentences (1) ──→ (N) Focused_Words
Sentences (1) ──→ (N) Learning_Records
Sentences (1) ──→ (N) Reading_Notes

Focused_Words (1) ──→ (N) Word_Phrases

Books (1) ──→ (N) Book_Chapters
Books (1) ──→ (N) Book_Summaries
Books (1) ──→ (N) Reading_Notes

Book_Chapters (1) ──→ (N) Book_Summaries
Book_Chapters (1) ──→ (N) Book_Chapters (self-reference for hierarchy)
```

### 关键索引设计

1. **性能优化索引**:
   - `users(username, email)` - 用户登录查询
   - `sentences(user_id, language_code, created_at)` - 句子查询和排序
   - `learning_records(user_id, next_review_at)` - 学习计划查询
   - `books(user_id, last_read_at)` - 最近阅读书籍

2. **全文搜索索引**:
   - `sentences(original_text)` - 句子内容搜索
   - `books(title, author)` - 书籍搜索
   - `reading_notes(note_text)` - 笔记搜索

### 数据约束和业务规则

1. **语言代码标准化**: 使用ISO 639-1标准 (如 'zh-CN', 'en-US', 'ja-JP')
2. **记忆曲线算法**: 基于Anki的SM-2算法实现间隔重复
3. **文件存储**: 支持多种电子书格式，文件路径加密存储
4. **数据完整性**: 级联删除确保数据一致性
5. **多语言支持**: 所有文本字段支持UTF-8编码

### 扩展性考虑

1. **多租户支持**: 通过user_id实现数据隔离
2. **API接口**: 预留RESTful API设计空间
3. **缓存策略**: 热点数据(学习记录、书籍信息)可考虑Redis缓存
4. **文件存储**: 支持云存储服务集成
5. **AI集成**: 预留AI翻译、总结、发音等功能的接口字段

用出色产品经理的标准，帮我复写需求文档。